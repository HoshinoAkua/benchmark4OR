import json
from gurobipy import Model, GRB

# Transportation Problem with Capacity Constraints
# Problem type: LP
# Domain: logistics_and_supply_chain
# Variant description: This variant of the classical transportation problem includes capacity constraints on the routes between warehouses and stores. Each route has a maximum capacity that cannot be exceeded.

# Read data
with open('data.json', 'r') as f:
    data = json.load(f)

### Read parameters from data
supply = data['supply']  # the supply available at each warehouse
demand = data['demand']  # the demand required at each retail store
cost = data['cost']  # the transportation cost from each warehouse to each retail store
capacity = data['capacity']  # the maximum capacity of each route from warehouse to store

### Get hyperparameter from parameters
num_warehouses = len(supply)  # number of warehouses
num_stores = len(demand)  # number of retail stores

# Create a new model
model = Model("Transportation Problem with Capacity Constraints")

### Add variables
# x[i,j] is the amount transported from warehouse i to store j
x = model.addVars(num_warehouses, num_stores, vtype=GRB.CONTINUOUS, name="x")

### Set objective
# Minimize the total transportation cost
model.setObjective(sum(cost[i][j] * x[i, j] for i in range(num_warehouses) for j in range(num_stores)), GRB.MINIMIZE)

### Add constraints
# Supply constraints: the total amount transported from each warehouse cannot exceed its supply
for i in range(num_warehouses):
    model.addConstr(sum(x[i, j] for j in range(num_stores)) <= supply[i], name=f"supply_{i}")

# Demand constraints: the total amount transported to each store must meet its demand
for j in range(num_stores):
    model.addConstr(sum(x[i, j] for i in range(num_warehouses)) >= demand[j], name=f"demand_{j}")

# Capacity constraints: the amount transported on each route cannot exceed its capacity
for i in range(num_warehouses):
    for j in range(num_stores):
        model.addConstr(x[i, j] <= capacity[i][j], name=f"capacity_{i}_{j}")

# Save the model as a '.lp' file.
model.write('model.lp')